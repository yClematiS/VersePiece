print([[
--------------------------------------------------------------------------------------
 ________  ___       _______   _____ ______   ________  _________  ___  ________      
|\   ____\|\  \     |\  ___ \ |\   _ \  _   \|\   __  \|\___   ___\\  \|\   ____\     
\ \  \___|\ \  \    \ \   __/|\ \  \\\__\ \  \ \  \|\  \|___ \  \_\ \  \ \  \___|_    
 \ \  \    \ \  \    \ \  \_|/_\ \  \\|__| \  \ \   __  \   \ \  \ \ \  \ \_____  \   
  \ \  \____\ \  \____\ \  \_|\ \ \  \    \ \  \ \  \ \  \   \ \  \ \ \  \|____|\  \  
   \ \_______\ \_______\ \_______\ \__\    \ \__\ \__\ \__\   \ \__\ \ \__\_________\
    \|_______|\|_______|\|_______|\|__|     \|__|\|__|\|__|    \|__|  \|__|\_________|

                        ___  ___  ___  ___  ________     
                        |\  \|\  \|\  \|\  \|\   __  \    
                        \ \  \\\  \ \  \\\  \ \  \|\ /_   
                         \ \   __  \ \  \\\  \ \   __  \  
                          \ \  \ \  \ \  \\\  \ \  \|\  \ 
                           \ \__\ \__\ \_______\ \_______\
                            \|__|\|__|\|_______|\|_______|
----------------------------------------------------------------------------------------------- --
]])


local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:FindFirstChild("HumanoidRootPart")

while not rootPart do
    rootPart = character:FindFirstChild("HumanoidRootPart")
    wait()
end

game:GetService("Players").LocalPlayer.Idled:connect(function()
    game:GetService("VirtualUser"):CaptureController()
    game:GetService("VirtualUser"):ClickButton2(Vector2.new())
end)

function getmaincode()
    local characters = "QWERTYUIOPASDFGHJKLZXCVBNM"
    local result = ""
    for i = 1, 1 do
        local randomIndex = math.random(2, #characters)
        result = result .. string.sub(characters, randomIndex, randomIndex)
    end
    return result
end

function getcode()
    local characters = "1234567890"
    local result = ""
    for i = 1, 5 do
        local randomIndex = math.random(2, #characters)
        result = result .. string.sub(characters, randomIndex, randomIndex)
    end
    return result
end

local function startTypingAnimation3()
    local randomText1 = getmaincode()
    local randomText2 = getcode()
    local username = game.Players.LocalPlayer.Character.Name
    random_name = " | Clematis Hub | " .. username .. " | Session : ( "..randomText1.."-"..randomText2.." ) "
end
spawn(startTypingAnimation3)

local usernames = game.Players.LocalPlayer.Character.Name
local pid = tostring(game.PlaceId)

print("Loading Lib")
_G.theme = "Amethyst"
wait(0.2)
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
print("Ui Lib Loaded")
wait(1)
print("Loading Function")
local MainWindow = Rayfield:CreateWindow({
    Name = random_name or "Clematis Hub | Err Loading | Session : ( Error! )",
    Icon = 0,
    LoadingTitle = "Loading!",
    LoadingSubtitle = "Script By Seaweed_hunter",
    Theme = _G.theme,
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "ClematisHub",
        FileName = usernames .. "_SavedConfig_" .. pid
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "Key?",
        Subtitle = "Key on Discord Server",
        Note = "Get Key From Discord",
        FileName = "Key",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"NOOOO"}
    }
})

--FLAG-----------------------------------------------------------------------------------

IsOnMob = false
IsMining = false
IsAutoHit = false
IsFastHit = false
IsWorldBoss = false
IsFindingWhip = false

--FLAG-----------------------------------------------------------------------------------

local MainTab = MainWindow:CreateTab("Auto Farm")
local InstantKill = MainTab:CreateSection("Kill Aura")
killmobpercent = {
    ["90%"] = 0.90,
    ["75%"] = 0.75,
    ["50%"] = 0.50,
    ["25%"] = 0.25,
    ["10%"] = 0.10,
}
defaultkillmobpercent = 0.90

local killmobpercentDropdown = MainTab:CreateDropdown({
    Name = "Kill Mob at %",
    Options = {"90%", "75%", "50%", "25%", "10%"},
    CurrentOption = "90%",
    MultipleOptions = false,
    Flag = "Inskillpercent",
    Callback = function(Option)
        local selected = type(Option) == "table" and Option[1] or Option
        if killmobpercent[selected] then
            defaultkillmobpercent = killmobpercent[selected]
        end
    end,
})

 local hitbox = nil
 local ShowHitbox = false
 local runService = game:GetService("RunService")
 
 local function createHitbox(radius)
     if hitbox then
         hitbox:Destroy()
     end
     hitbox = Instance.new("Part")
     hitbox.Shape = Enum.PartType.Ball
     hitbox.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
     hitbox.Material = Enum.Material.ForceField
     hitbox.CastShadow = false
     hitbox.Anchored = false
     hitbox.CanCollide = false
     hitbox.BrickColor = BrickColor.Red()
     hitbox.Massless = true
     hitbox.Parent = workspace
 end
 
 local function attachHitboxToCharacter()
     local me = game.Players.LocalPlayer.Character
     if not me then return end
 
     local hrp = me:FindFirstChild("HumanoidRootPart")
     if not hrp then return end
 
     if hitbox then
         hitbox.CFrame = hrp.CFrame
         
         local existingWeld = hitbox:FindFirstChildOfClass("WeldConstraint")
         if existingWeld then
             existingWeld:Destroy()
         end
         
         local weldConstraint = Instance.new("WeldConstraint")
         weldConstraint.Part0 = hrp
         weldConstraint.Part1 = hitbox
         weldConstraint.Parent = hitbox
     end
 end
 
 local function updateHitboxSize()
    if ShowHitbox then
         task.wait(0.1)
         if hitbox then
             local newSize = Vector3.new(defaultstudmob * 2, defaultstudmob * 2, defaultstudmob * 2)
             if hitbox.Size ~= newSize then
                 hitbox.Size = newSize
             end
         end
    end
 end
 
 local ShowHitboxToggle = MainTab:CreateToggle({
     Name = "Mob Search Distance",
     CurrentValue = false,
     Flag = "Mob Search",
     Callback = function(Value)
         ShowHitbox = Value
         if ShowHitbox then
             if not hitbox then
                 createHitbox(defaultstudmob)
             end
             attachHitboxToCharacter()
             task.spawn(updateHitboxSize)
         else
             if hitbox then
                 hitbox:Destroy()
                 hitbox = nil
             end
         end
     end
 })
 
 game.Players.LocalPlayer.CharacterAdded:Connect(function()
     if ShowHitbox then
         task.wait(1)
         createHitbox(defaultstudmob)
         attachHitboxToCharacter()
         task.spawn(updateHitboxSize)
     end
 end) 

 defaultstudmob = 150
local FindClosedMob = MainTab:CreateSlider({
    Name = "Find closest mob",
    Range = {10, 1040},
    Increment = 10,
    Suffix = "Stud",
    CurrentValue = 150,
    Flag = "closestmobb",
    Callback = function(Value)
    defaultstudmob = Value
    task.spawn(updateHitboxSize)
    end,
 })
 
 local SetHealth = false
 local hitboxThread = nil
 local KillAura = MainTab:CreateToggle({
     Name = "Instant Kill",
     CurrentValue = false,
     Flag = "Kill Aura",
     Callback = function(Value)
         SetHealth = Value
         
         if SetHealth and not hitboxThread then
             hitboxThread = task.spawn(function()
                if not SetHealth and hitboxThread then
                    task.cancel(hitboxThread)
                    hitboxThread = nil
                    return
                end
                 while SetHealth do
                     task.wait(0.1)
 
                     local success, errorMessage = pcall(function()
                         local mobFolder = workspace:FindFirstChild("Main")
                         local me = game.Players.LocalPlayer.Character
                         if not me then return end
                         local hrp = me:FindFirstChild("HumanoidRootPart")
                         if not hrp then return end
 
                         if mobFolder then
                             local plyRoot = hrp
                             local closestMob, closestDistance = nil, math.huge
                             for _, islandFolder in pairs(mobFolder:GetChildren()) do
                                 if islandFolder:IsA("Folder") then
                                     for _, mob in pairs(islandFolder:GetChildren()) do
                                         local mobHumanoid = mob:FindFirstChildOfClass("Humanoid")
                                         local rootPart = mob:FindFirstChild("HumanoidRootPart")
                                         local isMob = mob:FindFirstChild("Mob")
                                         
                                         if mobHumanoid and rootPart and isMob and isMob:IsA("BoolValue") and mobHumanoid.Health > 0 then
                                             local distance = (plyRoot.Position - rootPart.Position).Magnitude
                                             if distance < closestDistance then
                                                 closestDistance = distance
                                                 closestMob = mob
                                             end
                                         end
                                     end
                                     for _, mobGroupFolder in pairs(islandFolder:GetChildren()) do
                                         if mobGroupFolder:IsA("Folder") then
                                             for _, mob in pairs(mobGroupFolder:GetChildren()) do
                                                 local mobHumanoid = mob:FindFirstChildOfClass("Humanoid")
                                                 local rootPart = mob:FindFirstChild("HumanoidRootPart")
                                                 local isMob = mob:FindFirstChild("Mob")
                                                 
                                                 if mobHumanoid and rootPart and isMob and isMob:IsA("BoolValue") and mobHumanoid.Health > 0 then
                                                     local distance = (plyRoot.Position - rootPart.Position).Magnitude
                                                     if distance < closestDistance then
                                                         closestDistance = distance
                                                         closestMob = mob
                                                     end
                                                 end
                                             end
                                         end
                                     end
                                 end
                             end
                             if closestMob and closestDistance <= defaultstudmob then
                                 local humanoid = closestMob:FindFirstChildOfClass("Humanoid")
                                 local rootPart = closestMob:FindFirstChild("HumanoidRootPart")
                                 if humanoid and rootPart and humanoid.Health > 0 then
                                    
                                     
                                     if humanoid.Health < humanoid.MaxHealth * defaultkillmobpercent then
                                         humanoid.Health = 0
                                         humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                                     end
                                 end
                             end
                         end
                     end)
 
                     if not success then
                         warn("Error in KillAura loop: ", errorMessage)
                     end
                 end
                 hitboxThread = nil
             end)
         elseif not SetHealth and hitboxThread then
             hitboxThread = nil
         end
     end
 })

local MobFarmer = MainTab:CreateSection("Teleport to Mob")
local defaultrange = 6
local selectedMethod = "Up"

local function updateMobMethods()
    return {
        ["Front"] = CFrame.new(0, 0, -defaultrange) * CFrame.Angles(0, math.rad(180), 0),
        ["Up"] = CFrame.new(0, defaultrange, 0) * CFrame.Angles(math.rad(-90), 0, 0),
        ["Down"] = CFrame.new(0, -defaultrange, 0) * CFrame.Angles(math.rad(90), 0, 0),
        ["Behind"] = CFrame.new(0, 0, defaultrange) * CFrame.Angles(0, math.rad(0), 0),
    }
end

local mobMethods = updateMobMethods()
local defaultmobmethod = mobMethods[selectedMethod]
local mobDropdown = MainTab:CreateDropdown({
    Name = "Mob Farm Method",
    Options = {"Front", "Up", "Down", "Behind"},
    CurrentOption = selectedMethod,
    MultipleOptions = false,
    Flag = "mobmethod",
    Callback = function(Option)
        selectedMethod = type(Option) == "table" and Option[1] or Option
        defaultmobmethod = mobMethods[selectedMethod]
    end,
})

local FindClosedMob = MainTab:CreateSlider({
    Name = "Farm Mob Range",
    Range = {1, 20},
    Increment = 1,
    Suffix = "Stud",
    CurrentValue = defaultrange,
    Flag = "mobfarmrange",
    Callback = function(Value)
        defaultrange = Value
        mobMethods = updateMobMethods()
        defaultmobmethod = mobMethods[selectedMethod]
    end,
})

 local OnMob = false
 local Sittingsss = nil
 local GoToMob = MainTab:CreateToggle({
     Name = "Go to closest mob",
     CurrentValue = false,
     Flag = "OnMob",
     Callback = function(Value)
         OnMob = Value
         if OnMob and not Sittingsss then
             Sittingsss = task.spawn(function()
                 local bodyVelocity
                 while OnMob do
                     task.wait(0.1)
                     local success, errorMessage = pcall(function()
                         local mobFolder = workspace:FindFirstChild("Main")
                         local player = game.Players.LocalPlayer
                         local character = player.Character or player.CharacterAdded:Wait()
                         local humanoid = character:FindFirstChildOfClass("Humanoid")
                         local hrp = character:FindFirstChild("HumanoidRootPart")                        
                         
                        if IsMining then
                            return
                        end
                        
                        IsOnMob = true
                         if not humanoid or humanoid.Health <= 0 or not hrp then
                            IsOnMob = false
                             return
                         end

                         if not IsOnMob then
                            return
                         end

                         humanoid.PlatformStand = true
 
                         if bodyVelocity then
                             bodyVelocity:Destroy()
                         end
                         bodyVelocity = Instance.new("BodyVelocity")
                         bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
                         bodyVelocity.Velocity = Vector3.zero
                         bodyVelocity.Parent = hrp
 
                         if mobFolder then
                             local closestMob, closestDistance = nil, math.huge
                             for _, islandFolder in pairs(mobFolder:GetChildren()) do
                                 if islandFolder:IsA("Folder") then
                                     for _, mob in pairs(islandFolder:GetChildren()) do
                                         local mobHumanoid = mob:FindFirstChildOfClass("Humanoid")
                                         local rootPart = mob:FindFirstChild("HumanoidRootPart")
                                         local isMob = mob:FindFirstChild("Mob")
 
                                         if mobHumanoid and rootPart and isMob and isMob:IsA("BoolValue") and mobHumanoid.Health > 0 then
                                             local distance = (hrp.Position - rootPart.Position).Magnitude
                                             if distance < closestDistance then
                                                 closestDistance = distance
                                                 closestMob = mob
                                             end
                                         end
                                     end

                                     for _, mobGroupFolder in pairs(islandFolder:GetChildren()) do
                                         if mobGroupFolder:IsA("Folder") then
                                             for _, mob in pairs(mobGroupFolder:GetChildren()) do
                                                 local mobHumanoid = mob:FindFirstChildOfClass("Humanoid")
                                                 local rootPart = mob:FindFirstChild("HumanoidRootPart")
                                                 local isMob = mob:FindFirstChild("Mob")
 
                                                 if mobHumanoid and rootPart and isMob and isMob:IsA("BoolValue") and mobHumanoid.Health > 0 then
                                                     local distance = (hrp.Position - rootPart.Position).Magnitude
                                                     if distance < closestDistance then
                                                         closestDistance = distance
                                                         closestMob = mob
                                                     end
                                                 end
                                             end
                                         end
                                     end
                                 end
                             end
 
                             if closestMob and closestDistance <= defaultstudmob then
                                 local rootPart = closestMob:FindFirstChild("HumanoidRootPart")
                                 if rootPart then
                                     hrp.CFrame = rootPart.CFrame * defaultmobmethod
                                 end
                             end
                         end
                     end)
 
                     if not success then
                         warn("Error in GoToMob loop: ", errorMessage)
                     end
                 end
 
                 local player = game.Players.LocalPlayer
                 local character = player.Character
                 if character then
                     local humanoid = character:FindFirstChildOfClass("Humanoid")
                     local hrp = character:FindFirstChild("HumanoidRootPart")
 
                     if humanoid then
                         humanoid.PlatformStand = false
                     end
                     if hrp then
                         if bodyVelocity then
                             bodyVelocity:Destroy()
                         end
                         for _, obj in pairs(hrp:GetChildren()) do
                             if obj:IsA("BodyVelocity") then
                                 obj:Destroy()
                             end
                         end
                     end
                 end
                 Sittingsss = nil
             end)
            elseif not OnMob and Sittingsss then
                IsOnMob = false
                task.cancel(Sittingsss)
                Sittingsss = nil
                local player = game.Players.LocalPlayer
                local character = player.Character
                if character then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    local hrp = character:FindFirstChild("HumanoidRootPart")
    
                    if humanoid then
                        humanoid.PlatformStand = false
                    end
                    if hrp then
                        for _, obj in pairs(hrp:GetChildren()) do
                            if obj:IsA("BodyVelocity") then
                                obj:Destroy()
                            end
                        end
                    end
                end
            end
        end
    })

 Bosses = {
    "Lancer [Lv.???]",
    "Fallen Angel [Lv.???]",
    "D4C [Lv.???]",
    "Boss Island",
    "Skull"
}
SecBosses = {}

local WorldBossFarmer = MainTab:CreateSection("Auto World Boss")
AWBoss = MainTab:CreateDropdown({
    Name = "Select Boss",
    Options = Bosses,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "SelectBoss",
    Callback = function(Option)
        SecBosses = type(Option) == "table" and Option or {Option}
        print("Selected Bosses:", table.concat(SecBosses, ", "))
    end,
})

AutoWBoss = false
local function isBossSpawned(boss)
    if boss and boss:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = boss.HumanoidRootPart
        local billboard = humanoidRootPart:FindFirstChildOfClass("BillboardGui")
        if billboard and billboard.Enabled then
            return true
        end
    end
    return false
end

local function teleportToBoss(boss)
    if boss and boss:FindFirstChild("HumanoidRootPart") then
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = boss.HumanoidRootPart.CFrame*CFrame.new(0,0,defaultrange)
    end
end

local AutoBosses = MainTab:CreateToggle({
    Name = "Auto Goto Boss [If spawned]",
    CurrentValue = false,
    Flag = "ABoss",
    Callback = function(Value)
        AutoWBoss = Value
        while AutoWBoss do
            task.wait(0.1)
            for _, bossName in pairs(SecBosses) do
                local bossLocation = nil
                
                if bossName == "Lancer [Lv.???]" then
                    IsWorldBoss = true
                    bossLocation = workspace.Main.RaidBoss
                elseif bossName == "Fallen Angel [Lv.???]" then
                    IsWorldBoss = true
                    bossLocation = workspace.Main["Fallen Angel"]
                elseif bossName == "D4C [Lv.???]" then
                    IsWorldBoss = true
                    bossLocation = workspace.Main.Valentine
                elseif bossName == "Boss Island" then
                    if workspace.Main:FindFirstChild("Boss") then
                        for _, boss in pairs(workspace.Main.Boss:GetChildren()) do
                            if isBossSpawned(boss) then
                                IsWorldBoss = true
                                local success, err = pcall(function()
                                    local player = game.Players.LocalPlayer
                                    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                        player.Character.HumanoidRootPart.CFrame = CFrame.new(-1280.63513, 33.5067902, -990.815186)
                                    end
                                end)
                                if not success then
                                    warn("Failed to teleport to Boss Island:", err)
                                end
                            end
                        end
                    end
                elseif bossName == "Skull" then
                    if workspace.Main:FindFirstChild("Skull") then
                        for _, boss in pairs(workspace.Main.Skull:GetChildren()) do
                            if isBossSpawned(boss) then
                                IsWorldBoss = true
                                local success, err = pcall(function()
                                    local player = game.Players.LocalPlayer
                                    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                        player.Character.HumanoidRootPart.CFrame = CFrame.new(1083.94763, 26.8962345, -1687.422)
                                    end
                                end)
                                if not success then
                                    warn("Failed to teleport to Skull:", err)
                                end
                            end
                        end
                    end
                end

                if bossLocation then
                    for _, boss in pairs(bossLocation:GetChildren()) do
                        if boss.Name == bossName and isBossSpawned(boss) then
                            local success, err = pcall(function()
                                teleportToBoss(boss)
                            end)
                            if not success then
                                warn("Failed to teleport to boss:", bossName, err)
                            end
                        end
                    end
                end
                IsWorldBoss = false
            end
        end
    end,
})

local Mine = MainTab:CreateSection("Auto Mine Ore")
local Minning = false
local minedOre = {}
local oresToMine = 0
local oresMined = 0

local function mineOre(ore)
    local player = game.Players.LocalPlayer
    local humanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    local prompt = nil
    for _, obj in pairs(ore:GetDescendants()) do
        if obj:IsA("ProximityPrompt") and obj.Enabled then
            prompt = obj
            break
        end
    end
    if not prompt then
        return false
    end

    humanoidRootPart.CFrame = ore.PrimaryPart.CFrame * CFrame.new(0, 3, 0)

    local camera = game.Workspace.CurrentCamera
    local orePosition = ore.PrimaryPart.Position
    local cameraOffset = Vector3.new(0, 5, 0)
    camera.CFrame = CFrame.new(orePosition + cameraOffset, orePosition)
    task.wait(0.3)
    prompt.RequiresLineOfSight = false
    prompt:InputHoldBegin()
    task.wait(5)
    prompt:InputHoldEnd()

    minedOre[ore] = true
    return true
end

local MinningToggle = MainTab:CreateToggle({
    Name = "Auto Mine Ore",
    CurrentValue = false,
    Flag = "AOre",
    Callback = function(Value)
        Minning = Value
        local oreFolder = workspace.Main.Ore
        local player = game.Players.LocalPlayer

        if IsWorldBoss or IsFindingWhip then
            oresToMine = 0
            oresMined = 0
            minedOre = {}
            return
        end

        if not Minning then
            oresToMine = 0
            oresMined = 0
            minedOre = {}
            IsMining = false
        end

        while Minning do
            local character = player.Character or player.CharacterAdded:Wait()
            if not character then
                warn("Player character not found or died")
                wait(1)
                break
            end
            IsMining = true

            local ores = {}
            oresToMine = 0
            oresMined = 0

            for _, ore in pairs(oreFolder:GetChildren()) do
                if ore:IsA("Model") and ore.Name == "Ore" then
                    local promptFound = false
                    for _, obj in pairs(ore:GetDescendants()) do
                        if obj:IsA("ProximityPrompt") and obj.Enabled then
                            promptFound = true
                            oresToMine = oresToMine + 1
                            break
                        end
                    end

                    if promptFound and not minedOre[ore] then
                        table.insert(ores, ore)
                    end
                end
            end

            if oresToMine > 0 then
                for _, ore in ipairs(ores) do
                    if not Minning then break end
                    if mineOre(ore) then
                        oresMined = oresMined + 1
                        task.wait(0.5)
                    end
                end
            else
                wait(1)
            end

            if oresMined == oresToMine then
                minedOre = {}
                oresToMine = 0
                oresMined = 0
                wait(1)
            end

            wait(1)
        end
    end,
})


local Wisp = MainTab:CreateSection("Auto Find Wisp")
findingwisp = false
local Afindwisp = MainTab:CreateToggle({
    Name = "Auto Find Wisp",
    CurrentValue = false,
    Flag = "AFWisp",
    Callback = function(Value)
        findingwisp = Value
        local me = game.Players.LocalPlayer.Character

        if not me or not me:FindFirstChild("HumanoidRootPart") then
            return
        end
        if findingwisp then
        while findingwisp do
            task.wait(1)

            local whereiswisp = workspace:FindFirstChild("Main")
            if whereiswisp then
                whereiswisp = whereiswisp:FindFirstChild("Wisp")
            end

            if whereiswisp then
                for _, wisp in pairs(whereiswisp:GetChildren()) do
                    if wisp:IsA("Model") then
                        IsFindingWhip = true
                        local insidewisp = wisp:FindFirstChild("Torso")
                        if insidewisp then
                            local ininwisp = insidewisp:FindFirstChildOfClass("ProximityPrompt")
                            if ininwisp then
                                me.HumanoidRootPart.CFrame = insidewisp.CFrame
                                ininwisp.HoldDuration = 0
                                fireproximityprompt(ininwisp, 1)
                                IsFindingWhip = false
                            end
                        end
                    end
                end
            end
        end
    else
        IsFindingWhip = false
    end
    end,
})

local AutoSkill = MainWindow:CreateTab("Tools")
local Tools = AutoSkill:CreateSection("Tools")
local tool = {}
local playertools
local function refreshTools()
    tool = {}
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character then
        for _, obj in pairs(character:GetChildren()) do
            if obj:IsA("Tool") then
                table.insert(tool, obj.Name)
            end
        end
    end
    
    for _, obj in pairs(player.Backpack:GetChildren()) do
        if obj:IsA("Tool") then
            table.insert(tool, obj.Name)
        end
    end

    if playertools then
        playertools:Refresh(tool)
    end
end

local player = game.Players.LocalPlayer
local ATools = false
local defaulttool = ""

local function equipToolToCharacter()
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
        local tool = player.Backpack:FindFirstChild(defaulttool)
        if tool then
            local success, errorMessage = pcall(function()
                tool.Parent = character
            end)
            if not success then
                warn("Error equipping tool: ", errorMessage)
            end
        end
    end
end

playertools = AutoSkill:CreateDropdown({
    Name = "Select Tool",
    Options = tool,
    CurrentOption = defaulttool,
    MultipleOptions = false,
    Flag = "EquipTool",
    Callback = function(Option)
        local selected = type(Option) == "table" and Option[1] or Option
        if selected and table.find(tool, selected) then
            defaulttool = selected
        end
    end,
})

local refreshdropdowntool = AutoSkill:CreateButton({
    Name = "Refresh Tools",
    Callback = function()
        refreshTools()
    end,
})

refreshTools()

local AutoEquipToggle = AutoSkill:CreateToggle({
    Name = "Auto Equip Selected Tool",
    CurrentValue = false,
    Flag = "EquipSelectedTool",
    Callback = function(Value)
        ATools = Value
        if ATools then
            equipTask = task.spawn(function()
                while ATools do
                    equipToolToCharacter()
                    task.wait(0.1)
                end
            end)
        else
            if equipTask then
                task.cancel(equipTask)
            end
        end
    end,
})

player.CharacterAdded:Connect(function()
    if ATools then
        task.wait(1)
        equipToolToCharacter()
    end
end)

local autoattack = false
local AutoAttack = AutoSkill:CreateToggle({
    Name = "Auto Hit [No Animation]",
    CurrentValue = false,
    Flag = "AHit",
    Callback = function(Value)
        autoattack = Value
        while autoattack do
            local success, err = pcall(function()
                local player = game.Players.LocalPlayer
                local equippedTool = player.Character and player.Character:FindFirstChildOfClass("Tool")

                if not equippedTool then
                    error("No tool equipped.")
                end

                local toolstype = equippedTool:FindFirstChildOfClass("BoolValue")
                if not toolstype then
                    error("No item type found in the tool.")
                end

                local args = {
                    [1] = "Server",
                    [2] = toolstype.Name,
                    [3] = "M1s", 
                    [4] = nil,
                    [5] = equippedTool.Name
                }
                game:GetService("ReplicatedStorage").Remotes.Serverside:FireServer(unpack(args))
            end)

            task.wait(0.12)
            if not autoattack then break end
        end
    end
})

local quickautoattack = false
local count = 1
local attackTask
local quickattack = AutoSkill:CreateToggle({
    Name = "Auto Fast Hit [Animation]",
    CurrentValue = false,
    Flag = "quickautoattack",
    Callback = function(Value)
        quickautoattack = Value
        
        if quickautoattack then
            attackTask = task.spawn(function()
                while quickautoattack do
                    local player = game.Players.LocalPlayer
                    local equippedTool = player.Character and player.Character:FindFirstChildOfClass("Tool")

                    if equippedTool then
                        local toolstype = equippedTool:FindFirstChildOfClass("BoolValue")
                        if toolstype then
                            local args = {
                                [1] = "Server",
                                [2] = toolstype.Name,
                                [3] = "M1s", 
                                [4] = count,
                                [5] = equippedTool.Name
                            }
                            task.spawn(function()
                                game:GetService("ReplicatedStorage").Remotes.Serverside:FireServer(unpack(args))
                            end)
                            
                            count = count + 1
                            if count > 5 then
                                count = 1
                            end
                        end
                    end

                    task.wait(0.01)
                end
            end)
        else
            if attackTask then
                task.cancel(attackTask)
            end
        end
    end
})

local Skills = AutoSkill:CreateSection("Skill Selection")
secskills = {
    ["Skill 1"] = "Move1",
    ["Skill 2"] = "Move2",
    ["Skill 3"] = "Move3",
    ["Skill 4"] = "Move4",
    ["Skill 5"] = "Move5",
}
defaultsecskills = {}

local skillsecdropdown = AutoSkill:CreateDropdown({
    Name = "Select Skill",
    Options = {"Skill 1", "Skill 2", "Skill 3", "Skill 4", "Skill 5"},
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "Select Skill",
    Callback = function(Options)
        defaultsecskills = {}

        for _, selected in ipairs(Options) do
            if secskills[selected] then
                table.insert(defaultsecskills, secskills[selected])
            end
        end
    end,
})

local spamskill = false
local spamskill = AutoSkill:CreateToggle({
    Name = "Auto Skills",
    CurrentValue = false,
    Flag = "skillz",
    Callback = function(Value)
        spamskill = Value
        while spamskill do
            local success, err = pcall(function()
                if #defaultsecskills == 0 then
                    error("No skill selected.")
                end

                local player = game.Players.LocalPlayer
                local equippedTool = player.Character and player.Character:FindFirstChildOfClass("Tool")

                if not equippedTool then
                    error("No tool equipped.")
                end

                local toolstype = equippedTool:FindFirstChildOfClass("BoolValue")
                if toolstype.Name == "Fruit" or "Sword" then
                    combattype = toolstype.Name
                end
                if toolstype.Name == "Combat" then
                    combattype = "Special"
                end
                if not toolstype then
                    error("No item type found in the tool.")
                end

                for _, skill in ipairs(defaultsecskills) do
                    local args = {
                        [1] = "Server",
                        [2] = combattype,
                        [3] = skill,
                        [4] = true,
                        [5] = equippedTool.Name
                    }
                    game:GetService("ReplicatedStorage").Remotes.Serverside:FireServer(unpack(args))
                    task.wait(0.2)
                end
            end)

            task.wait(0.5)
            if not spamskill then break end
        end
    end
})

local autoabilly = false
local autoabilly = AutoSkill:CreateToggle({
    Name = "Auto Ability",
    CurrentValue = false,
    Flag = "skillz",
    Callback = function(Value)
        autoabilly = Value
        while autoabilly do
            pcall(function()
                local args = {
                    [1] = "Server",
                    [2] = "Misc",
                    [3] = "Ability"
                }
                
                game:GetService("ReplicatedStorage").Remotes.Serverside:FireServer(unpack(args))
            end)
            task.wait(0.5)
            if not autoabilly then break end
        end
    end
})

local location = MainWindow:CreateTab("Teleport")
local gotoplayer = location:CreateSection("Players")
local GotoPlayerRepeat = false
local defaultotherplayer = ""
local otplayers = {}

local otherplayers = location:CreateDropdown({
    Name = "Select Player",
    Options = otplayers,
    CurrentOption = defaultotherplayer,
    MultipleOptions = false,
    Callback = function(Option)
        local selected = type(Option) == "table" and Option[1] or Option
        if selected and table.find(otplayers, selected) then
            defaultotherplayer = selected
        end
    end,
})

local function refreshplayers()
    otplayers = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(otplayers, player.Name)
        end
    end
    if otherplayers then
        otherplayers:Refresh(otplayers)
    end
end

local refreshdropdownplayers = location:CreateButton({
    Name = "Refresh Players",
    Callback = function()
        refreshplayers()
    end,
})

local GotoPlayerToggle = location:CreateToggle({
    Name = "Goto Selected Player",
    CurrentValue = false,
    Callback = function(Value)
        GotoPlayerRepeat = Value
        if GotoPlayerRepeat then
            task.spawn(function()
                while GotoPlayerRepeat do
                    wait(0.1)

                    local success, err = pcall(function()
                        local targetPlayer = game.Players:FindFirstChild(defaultotherplayer)
                        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            local me = game.Players.LocalPlayer.Character
                            if me and me:FindFirstChild("HumanoidRootPart") then
                                me:PivotTo(targetPlayer.Character.HumanoidRootPart.CFrame*CFrame.new(0,1,2))
                            end
                        end
                    end)
                    
                    if not success then
                        warn(err)
                    end
                end
            end)
        end
    end,
})

refreshplayers()
local map = location:CreateSection("Islands")

for _, obj in pairs(workspace.Map:GetChildren()) do
    if obj:IsA("Model") then
        local primary = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
        
        if primary then
            location:CreateButton({
                Name = obj.Name,
                Callback = function()
                    local me = game.Players.LocalPlayer.Character
                    if me and me:FindFirstChild("HumanoidRootPart") then
                        me:PivotTo(primary.CFrame*CFrame.new(0,70,0))
                    end
                end
            })
        end
    end
end

local MiscTab = MainWindow:CreateTab("Misc")

local AutoClick = MiscTab:CreateSection("Auto Click")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer
local screenGui = CoreGui:FindFirstChild("CrosshairGui")

if not screenGui then
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CrosshairGui"
    screenGui.Parent = CoreGui

    local crosshair = Instance.new("ImageLabel")
    crosshair.Size = UDim2.new(0, 45, 0, 45)
    crosshair.Position = UDim2.new(0.5, -5, 0.5, 260)
    crosshair.BackgroundTransparency = 1
    crosshair.Image = "rbxassetid://103448393060927"
    crosshair.Parent = screenGui
    
    local dragging, dragInput, dragStart, startPos

    local function Update(input)
        local delta = input.Position - dragStart
        crosshair.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end

    local function StartDrag(input)
        dragging = true
        dragStart = input.Position
        startPos = crosshair.Position
    end

    local function StopDrag()
        dragging = false
    end

    crosshair.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            StartDrag(input)
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    StopDrag()
                end
            end)
        end
    end)

    crosshair.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            Update(input)
        end
    end)
end

local function endClick()
    local success, errorMessage = pcall(function()
        local crosshair = screenGui:FindFirstChildOfClass("ImageLabel")
        if crosshair then
            local midX, midY = crosshair.AbsolutePosition.X + 10, crosshair.AbsolutePosition.Y + 10
            VirtualInputManager:SendMouseButtonEvent(midX, midY, 0, true, game, 0)
            task.wait(0.1)
            VirtualInputManager:SendMouseButtonEvent(midX, midY, 0, false, game, 0)
        end
    end)
    
    if not success then
        warn("Error in endClick:", errorMessage)
    end
end


local Clicking = false
local clickThread = nil
Clicking = MiscTab:CreateToggle({
    Name = "Auto Click",
    CurrentValue = false,
    Flag = "Clicking",
    Callback = function(Value)
        Clicking = Value
        if Clicking and not clickThread then
            clickThread = task.spawn(function()
                while Clicking do
                    local success, errorMessage = pcall(function()
                        endClick()
                    end)
                    
                    if not success then
                        warn("Error in Auto Click loop:", errorMessage)
                    end
                    
                    game:GetService("RunService").RenderStepped:Wait()
                end
            end)
        elseif not Clicking and clickThread then
            clickThread = nil
        end
    end
})

local PlayerPlus = MiscTab:CreateSection("Player")
local defaultMaxZoom = game.Players.LocalPlayer.CameraMaxZoomDistance
local Maxzoom = MiscTab:CreateToggle({
    Name = "Unlock Max Zoom",
    CurrentValue = false,
    Flag = "Maxzoom",
    Callback = function(Value)
        if Value then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
        else
            game.Players.LocalPlayer.CameraMaxZoomDistance = defaultMaxZoom
        end
    end,
})

local ClearMobs = MiscTab:CreateSection("Clear All Loaded Mobs")
local ClearMob = MiscTab:CreateButton({
    Name = "Clear All Loaded Mobs [RISK]",
    Callback = function()
        local tofindmob = workspace.Main
        for i,v in pairs(tofindmob:GetDescendants()) do
            if v.Name == "Humanoid" then
                v.Health = 0
        end
    end
    end,
 })

Rayfield:LoadConfiguration()

_G.searcherayfield = true
local foundray = false
while _G.searcherayfield and not foundray do
    task.wait(1)
    local coreGui = game:GetService("CoreGui")
    for _, v in pairs(coreGui:GetDescendants()) do
        if v.Name == "Rayfield" then
            local rayfie = v
            foundray = true
            _G.searcherayfield = false
            rayfie.Enabled = false

            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "ToggleRayfield"
            screenGui.Parent = coreGui

            local shadowframe = Instance.new("Frame")
            shadowframe.Size = UDim2.new(0, 100, 0, 100)
            shadowframe.Position = UDim2.new(0.015, 0, 0.2, 0)
            shadowframe.BackgroundTransparency = 0.8
            shadowframe.BorderSizePixel = 0
            shadowframe.BackgroundColor3 = Color3.fromRGB(153, 102, 204)
            shadowframe.Parent = screenGui

            local shadowcorner = Instance.new("UICorner")
            shadowcorner.CornerRadius = UDim.new(0.2, 0)
            shadowcorner.Parent = shadowframe

            local shadowbutton = Instance.new("ImageButton")
            shadowbutton.Size = UDim2.new(1, 0, 1, 0)
            shadowbutton.BackgroundTransparency = 1
            shadowbutton.Image = "http://www.roblox.com/asset/?id=83415391084673"
            shadowbutton.ImageColor3 = Color3.fromRGB(0,0,0)
            shadowbutton.Parent = shadowframe

            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(0, 100, 0, 100)
            frame.Position = UDim2.new(0.015, 0, 0.2, 0)
            frame.BackgroundTransparency = 0.5
            frame.BorderSizePixel = 0
            frame.BackgroundColor3 = Color3.fromRGB(153, 102, 204)
            frame.Parent = screenGui

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0.2, 0)
            corner.Parent = frame

            local button = Instance.new("ImageButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Image = "http://www.roblox.com/asset/?id=83415391084673"
            button.ImageColor3 = Color3.fromRGB(255, 255, 255)
            button.Parent = frame
            

            local isEnabled = false
            button.MouseButton1Click:Connect(function()
                isEnabled = not isEnabled
                rayfie.Enabled = isEnabled
                local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
                local goal = {Size = UDim2.new(0, 120, 0, 120)}
                local tween = game:GetService("TweenService"):Create(button, tweenInfo, goal)
                tween:Play()
                tween.Completed:Connect(function()
                    local returnTween = game:GetService("TweenService"):Create(button, tweenInfo, {Size = UDim2.new(0, 100, 0, 100)})
                    returnTween:Play()
                end)
            end)
            local dragging = false
            local dragInput, mousePos, buttonPos
            local userInputService = game:GetService("UserInputService")

            button.InputBegan:Connect(function(input, gameProcessedEvent)
                if gameProcessedEvent then return end
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = true
                    mousePos = input.Position
                    buttonPos = button.Position
                end
            end)

            button.InputChanged:Connect(function(input)
                if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                    local delta = input.Position - mousePos
                    button.Position = UDim2.new(buttonPos.X.Scale, buttonPos.X.Offset + delta.X, buttonPos.Y.Scale, buttonPos.Y.Offset + delta.Y)
                end
            end)

            button.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = false
                end
            end)
            break
        end
    end
end
